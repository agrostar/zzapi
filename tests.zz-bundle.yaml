# yaml-language-server: $schema=https://raw.githubusercontent.com/agrostar/zzapi/main/schema.json
# yaml-language-server: $schema=./schema.json

# This bundle contains a series of test requests against various endpoints,
# most of them being the postman echo service. We use this to both serve as
# an example of how to create test bundles as well as testing zzapi runner itself.

common:
  baseUrl: https://postman-echo.com
  headers:
    - { name: Content-type, value: application/json }
  tests:
    status: 200
    headers:
      Content-type: application/json; charset=utf-8

requests:

  simple-get: { method: GET, url: /simpleget }

  get-with-params:
    method: GET
    url: /get
    params:
      - { name: foo1, value: bar1 }
      - { name: foo2, value: bar2 }
    tests:
      json: { $.args.foo1: bar1,  $.args.foo2: bar2 }

  post-header-merge:
    url: /post
    method: POST
    headers: 
      - { name: X-Custom-Header, value: Custom Value }
    body:
      foo1: bar1
      foo2: 42
    tests:
      json: 
        $.data.foo1: bar1
        $.data.foo2: { $type: number, $gt: 41, $lt: 43 }
        $.headers.X-Custom-Header: Custom Value

  post-header-override:
    url: /post
    method: POST
    headers: 
      - { name: Content-Type, value: text/plain }
    body: { foo: bar }
    tests:
      # if the server didn't parse this as a JSON, then, our content-type override is successful
      json: { $.data: '{"foo":"bar"}' }

  status-404:
    url: /notfound
    method: GET
    tests: { status: 404 }

  status-401:
    url: /status/401
    method: GET
    tests: { status: 401, { json: { $.status: 401 } } }

  encoding:
    method: GET
    url: /get
    params:
      - { name: foo, value: 30% of 200 is 60 }
    tests:
      json:
        $.url: https://postman-echo.com/get?foo=30%25%20of%20200%20is%2060
        $.args.foo: 30% of 200 is 60

  no-encoding:
    method: GET
    url: /get
    params:
      - { name: foo, value: 30%25+of+200, encode: false }
    tests:
      json:
        $.url: https://postman-echo.com/get?foo=30%25+of+200
        $.args.foo: 30% of 200
    # capture:
    #   json:
    #     $.args.foo: username
    #   status: myUsername

  # The cookies endpoint does a redirect (no clue why), let's use that.
  no-redirects:
    method: GET
    url: /cookies/set
    tests:
      status: 302
      headers: { Location: /cookies,  Content-Type: { $ne: application/json } }

  redirects:
    options:
      follow: true
    method: GET
    url: /cookies/set
    tests:
      # code: 200 - this is inherited from common
      json: { $.cookies: { $exists: true } } # Header names are case insensitive

  non-json:
    method: GET
    url: /encoding/utf8
    tests:
      body: { $regex: unicode demo, $options: i }
      headers: 
        content-type: text/html; charset=utf-8

  response-headers:
    method: GET
    url: /response-headers
    params:
      - { name: foo, value: bar }
    tests: { headers: { foo: bar } }

  override-base-url:
    method: GET
    url: https://postman-echo.com/get

  variables-in-params:
    method: GET
    url: $(getUrl)
    params:
      - { name: replaced1, value: $username }
      - { name: replaced2, value: some$myUsername }
      - { name: replaced3, value: some$(myUsername)else }
      - { name: verbatim1, value: $usernameelse }
      - { name: verbatim2, value: \$(username) }
    tests:
      json:
        $.args.replaced1: vasan.subramanian
        $.args.replaced2: somevasan.subramanian
        $.args.replaced3: somevasan.subramanianelse
        $.args.verbatim1: { $ne: vasan.subramaniansome, $eq: $usernameelse }
        $.args.verbatim2: { $ne: vasan.subramanian, $eq: \$(username) }

  variables-in-headers:
    method: GET
    url: $(getUrl)
    headers:
      - { name: foo, value: $(fooValue) }
    tests: { json: { $.headers.foo: bar } }

  variables-in-body:
    method: POST
    url: /post
    body: |   # Alternate way of supplying the JSON string or any raw content
      {
        "foo1": "$(fooValue)",
        "foo2": $pi
      }
    tests:
      json: { $.data.foo1: bar,  $.data.foo2: { $type: number, $eq: 3.414 } }

  # This returns headers in capital case. Ensure we match it.
  header-case:
    method: GET
    url: https://test-farmerapp.agrostar.in/userservice/ping/
    tests: 
      headers:
        content-type: application/json

  tests-positive:
    method: POST
    url: /post
    body:
      firstName: John
      lastName: Doe
      middleName: null
      age: 26
      address:
        streetAddress: naist street
        city: Nara
        postalCode: "560034" #string
      phoneNumbers:
        - type: mobile
          number: 0123-4567-8888
          available: [ 7, 22 ]
        - type: home
          number: 0123-4567-8910
          available: [18, 22]
    tests:
      json:
        $.data.firstName: John
        $.data.age: { $type: number, $eq: 26, $ne: 26, $gt: 25, $lt: 27 }
        $.data.address: { $type: object, $size: 3, $exists: true }
        $.data.address.city: Nara
        $.data.address.postalCode: { $type: string, $size: 6, $ne: 560034 }
        $.data.phoneNumbers: { $type: array, $size: 2, $exists: true }
        $.data.phoneNumbers[0].type: mobile
        $.data.phoneNumbers.1.type: home
        $.data.phoneNumbers[?(@.type=="home")].number: 0123-4567-8910
        $.data.lastName: { $exists: true }
        $.data.middleName: { $exists: true, $type: "null" }
        $.data.otherName: { $exists: false, $type: undefined }
        $.data.phoneNumbers[*].type: mobile
        $.data.phoneNumbers[*].available: { $eq: [7,22] }
        $.data.phoneNumbers.0.available: { $eq: [ 7, 22 ], $type: array }
        $.data.phoneNumbers.1.available: { $eq: "[18,22]", $type: array }
        # stress: ensure corner cases don't crash
        $.data.otherName.value: { $exists: false } # don't recurse down undefined
        $.data.middleName.value: { $exists: false } # don't recurse down null

  # All these tests should fail
  tests-negative-response:
    method: POST
    url: /post
    body:
      age: 26
      name: John
      address: 1, example street
      numbers: [ 444, 222 ]
      object: { foo: bar }
    tests:
      json:
        # regular things that should fail
        $.data.name: { $type: array }
        $.data.missing: { $size: 0, $exists: true } # should report 2 failures
        $.data.missing.missing.missing: { $exists: true }
        $.data.numbers.0: "444" # 444 is not same as "444". We use === for $eq and !== for $neq

        # stress: ensure corner cases don't crash
        $.data.age: { $size: 2 }  # .length not supported for type: number
        $.data.numbers[?(.@)]: 4 # invalid path
        $.data.age.something: 55  # jsonpath should take care of this.
        $.data.numbers[5]: 0  # jsonpath should take care of this 

  # This request should not even be processed due to bad tests schema
  tests-negative-schema:
    method: GET
    url: /get
    tests:
      json:
        $.data.operator: { badop: any }  # invalid operator badop. If you want to match an entire object/array, use it as the value of the $eq operator.
        $.data.numbers: { $size: two } # invalid assertion value, expecting a number
        $.data.address: { $type: invalid } # invalid assertion value, expecting one of number|string|array|object|null|undefined
        $.data.exists: { $exists: 4 } # invalid assertion value, expecitng a boolean

  capture-json:
    method: POST
    url: /post
    body:
      name: Tom
      address: { city: Bangalore, pincode: 560001 }
    capture:
      json:
        $.data.name: nameVar
        $.data.address: addressVar
        $.data.address.city: cityVar
        $.data.address.pincode: pincodeVar

  capture-header:
    method: GET
    url: /response-headers
    params:
      - { name: X-Custom-Header, value: Custom header value }
    capture:
      headers:
        X-Custom-Header: customHeaderVar

  capture-checks-scalar:
    method: POST
    url: /post
    body:
      name: $nameVar
      city: $cityVar
      pincode: $pincodeVar
      customHeader: $customHeaderVar
    tests:
      json:
        $.data.name: Tom
        $.data.city: Bangalore
        $.data.pincode: 560001
        $.data.customHeader: Custom Header Value

  capture-checks-object-option-1:
    method: POST
    url: /post
    # The body is a string, so that we can use the JSON as is in the replacement
    # Therefore, it is NOT "$addressVar"
    body: |
      {
        "name": "Tom",
        "address": $addressVar
      }
    tests:
      json:
        $.data.name: Tom
        $.data.address.city: Bangalore
        $.data.address.pincode: 560001  # this time it is NOT a string.

  capture-checks-object-option-2:
    method: POST
    url: /post
    # The body is a string, so that we can use the JSON as is in the replacement
    body:
      name: Tom
      address: $addressVar
    tests:
      json:
        $.data.name: Tom
        $.data.address: { $eq: { city: Bangalore, pincode: 560001 } }

# Do we capture variables in their native data type, or do we stringify them?
# Best of both would be the best. We favour JSON, so capturing native data type
# and using them in the body: (not string format, but object format) would appear
# natural. But that is hard work. We have to dscend into each nested object and
# replace all the values. Even array values. Is it worth it? Yes.
